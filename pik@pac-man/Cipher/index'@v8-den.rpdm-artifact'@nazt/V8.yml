					{	
	"image": "mcr.microsoft.com/devcontainers/javascript-node:0-18",					
	"customizations": {					
	"vscode": {					
	"extensions": [					
	"mads-hartmann.bash-ide-vscode"					
	]					
	}					
	},					
	"features": {					
	"ghcr.io/devcontainers/features/docker-in-docker:2": {}					
	},					
	"remoteUser": "node",					
	"postCreateCommand": "npm install -g @devcontainers/cli"					
	}					
					47  .github/workflows/release.yaml	
	@@ -0,0 +1,47 @@					
	name: "Release dev container features & Generate Documentation"					
	on:					
	workflow_dispatch:					
						
	jobs:					
	deploy:					
	if: ${{ github.ref == 'refs/heads/main' }}					
	runs-on: ubuntu-latest					
	permissions:					
	contents: write					
	pull-requests: write					
	packages: write					
	steps:					
	- uses: actions/checkout@v3					
						
	- name: "Publish Features"					
	uses: devcontainers/action@v1					
	with:					
	publish-features: "true"					
	base-path-to-features: "./src"					
	generate-docs: "true"					
						
	env:					
	GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}					
						
	- name: Create PR for Documentation					
	id: push_image_info					
	env:					
	GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}					
	run: |					
	set -e					
	echo "Start."					
	# Configure git and Push updates					
	git config --global user.email github-actions@github.com					
	git config --global user.name github-actions					
	git config pull.rebase false					
	branch=automated-documentation-update-$GITHUB_RUN_ID					
	git checkout -b $branch					
	message='Automated documentation update'					
	# Add / update and commit					
	git add */**/README.md					
	git commit -m 'Automated documentation update [skip ci]' || export NO_UPDATES=true					
	# Push					
	if [ "$NO_UPDATES" != "true" ] ; then					
	git push origin "$branch"					
	gh pr create --title "$message" --body "$message"					
	fi					
					58  .github/workflows/test.yaml	
	@@ -0,0 +1,58 @@					
	name: "CI - Test Features"					
	on:					
	push:					
	branches:					
	- main					
	pull_request:					
	workflow_dispatch:					
						
	jobs:					
	test-autogenerated:					
	runs-on: ubuntu-latest					
	continue-on-error: true					
	strategy:					
	matrix:					
	features:					
	- color					
	- hello					
	baseImage:					
	- debian:latest					
	- ubuntu:latest					
	- mcr.microsoft.com/devcontainers/base:ubuntu					
	steps:					
	- uses: actions/checkout@v3					
						
	- name: "Install latest devcontainer CLI"					
	run: npm install -g @devcontainers/cli					
						
	- name: "Generating tests for '${{ matrix.features }}' against '${{ matrix.baseImage }}'"					
	run: devcontainer features test --skip-scenarios -f ${{ matrix.features }} -i ${{ matrix.baseImage }} .					
						
	test-scenarios:					
	runs-on: ubuntu-latest					
	continue-on-error: true					
	strategy:					
	matrix:					
	features:					
	- color					
	- hello					
	steps:					
	- uses: actions/checkout@v3					
						
	- name: "Install latest devcontainer CLI"					
	run: npm install -g @devcontainers/cli					
						
	- name: "Generating tests for '${{ matrix.features }}' scenarios"					
	run: devcontainer features test -f ${{ matrix.features }} --skip-autogenerated .					
						
	test-global:					
	runs-on: ubuntu-latest					
	continue-on-error: true					
	steps:					
	- uses: actions/checkout@v3					
						
	- name: "Install latest devcontainer CLI"					
	run: npm install -g @devcontainers/cli					
						
	- name: "Testing global scenarios"					
	run: devcontainer features test --global-scenarios-only .					
					16  .github/workflows/validate.yml	
	@@ -0,0 +1,16 @@					
	name: "Validate devcontainer-feature.json files"					
	on:					
	workflow_dispatch:					
	pull_request:					
						
	jobs:					
	validate:					
	runs-on: ubuntu-latest					
	steps:					
	- uses: actions/checkout@v3					
						
	- name: "Validate devcontainer-feature.json files"					
	uses: devcontainers/action@v1					
	with:					
	validate-only: "true"					
	base-path-to-features: "./src"					
					21  LICENSE	
					184  README.md	
	@@ -0,0 +1,184 @@					
	# Dev Container Features: Self Authoring Template					
						
	> This repo provides a starting point and example for creating your own custom [dev container Features](https://containers.dev/implementors/features/), hosted for free on GitHub Container Registry. The example in this repository follows the [dev container Feature distribution specification](https://containers.dev/implementors/features-distribution/).					
	>					
	> To provide feedback to the specification, please leave a comment [on spec issue #70](https://github.com/devcontainers/spec/issues/70). For more broad feedback regarding dev container Features, please see [spec issue #61](https://github.com/devcontainers/spec/issues/61).					
						
	## Example Contents					
						
	This repository contains a _collection_ of two Features - `hello` and `color`. These Features serve as simple feature implementations. Each sub-section below shows a sample `devcontainer.json` alongside example usage of the Feature.					
						
	### `hello`					
						
	Running `hello` inside the built container will print the greeting provided to it via its `greeting` option.					
						
	```jsonc					
	{					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"ghcr.io/devcontainers/feature-starter/hello:1": {					
	"greeting": "Hello"					
	}					
	}					
	}					
	```					
						
	```bash					
	$ hello					
						
	Hello, user.					
	```					
						
	### `color`					
						
	Running `color` inside the built container will print your favorite color to standard out.					
						
	```jsonc					
	{					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"ghcr.io/devcontainers/feature-starter/color:1": {					
	"favorite": "green"					
	}					
	}					
	}					
	```					
						
	```bash					
	$ color					
						
	my favorite color is green					
	```					
						
	## Repo and Feature Structure					
						
	Similar to the [`devcontainers/features`](https://github.com/devcontainers/features) repo, this repository has a `src` folder. Each Feature has its own sub-folder, containing at least a `devcontainer-feature.json` and an entrypoint script `install.sh`.					
						
	```					
	├── src					
	│ ├── hello					
	│ │ ├── devcontainer-feature.json					
	│ │ └── install.sh					
	│ ├── color					
	│ │ ├── devcontainer-feature.json					
	│ │ └── install.sh					
	| ├── ...					
	│ │ ├── devcontainer-feature.json					
	│ │ └── install.sh					
	...					
	```					
						
	An [implementing tool](https://containers.dev/supporting#tools) will composite [the documented dev container properties](https://containers.dev/implementors/features/#devcontainer-feature-json-properties) from the feature's `devcontainer-feature.json` file, and execute in the `install.sh` entrypoint script in the container during build time. Implementing tools are also free to process attributes under the `customizations` property as desired.					
						
	### Options					
						
	All available options for a Feature should be declared in the `devcontainer-feature.json`. The syntax for the `options` property can be found in the [devcontainer Feature json properties reference](https://containers.dev/implementors/features/#devcontainer-feature-json-properties).					
						
	For example, the `color` feature provides an enum of three possible options (`red`, `gold`, `green`). If no option is provided in a user's `devcontainer.json`, the value is set to "red".					
						
	```jsonc					
	{					
	// ...					
	"options": {					
	"favorite": {					
	"type": "string",					
	"enum": [					
	"red",					
	"gold",					
	"green"					
	],					
	"default": "red",					
	"description": "Choose your favorite color."					
	}					
	}					
	}					
	```					
						
	Options are exported as Feature-scoped environment variables. The option name is captialized and sanitized according to [option resolution](https://containers.dev/implementors/features/#option-resolution).					
						
	```bash					
	#!/bin/bash					
						
	echo "Activating feature 'color'"					
	echo "The provided favorite color is: ${FAVORITE}"					
						
	...					
	```					
						
	## Distributing Features					
						
	### Versioning					
						
	Features are individually versioned by the `version` attribute in a Feature's `devcontainer-feature.json`. Features are versioned according to the semver specification. More details can be found in [the dev container Feature specification](https://containers.dev/implementors/features/#versioning).					
						
	### Publishing					
						
	> NOTE: The Distribution spec can be [found here](https://containers.dev/implementors/features-distribution/).					
	>					
	> While any registry [implementing the OCI Distribution spec](https://github.com/opencontainers/distribution-spec) can be used, this template will leverage GHCR (GitHub Container Registry) as the backing registry.					
						
	Features are meant to be easily sharable units of dev container configuration and installation code.					
						
	This repo contains a GitHub Action [workflow](.github/workflows/release.yaml) that will publish each feature to GHCR. By default, each Feature will be prefixed with the `<owner/<repo>` namespace. For example, the two Features in this repository can be referenced in a `devcontainer.json` with:					
						
	```					
	ghcr.io/devcontainers/feature-starter/color:1					
	ghcr.io/devcontainers/feature-starter/hello:1					
	```					
						
	The provided GitHub Action will also publish a third "metadata" package with just the namespace, eg: `ghcr.io/devcontainers/feature-starter`. This contains information useful for tools aiding in Feature discovery.					
						
	`devcontainers/feature-starter`' is known as the feature collection namespace.					
						
	### Marking Feature Public					
						
	Note that by default, GHCR packages are marked as `private`. To stay within the free tier, Features need to be marked as `public`.					
						
	This can be done by navigating to the Feature's "package settings" page in GHCR, and setting the visibility to 'public`. The URL may look something like:					
						
	```					
	https://github.com/users/<owner>/packages/container/<repo>%2F<featureName>/settings					
	```					
						
	<img width="669" alt="image" src="https://user-images.githubusercontent.com/23246594/185244705-232cf86a-bd05-43cb-9c25-07b45b3f4b04.png">					
						
	### Adding Features to the Index					
						
	If you'd like your Features to appear in our [public index](https://containers.dev/features) so that other community members can find them, you can do the following:					
						
	* Go to [github.com/devcontainers/devcontainers.github.io](https://github.com/devcontainers/devcontainers.github.io)					
	* This is the GitHub repo backing the [containers.dev](https://containers.dev/) spec site					
	* Open a PR to modify the [collection-index.yml](https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml) file					
						
	This index is from where [supporting tools](https://containers.dev/supporting) like [VS Code Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) and [GitHub Codespaces](https://github.com/features/codespaces) surface Features for their dev container creation UI.					
						
	#### Using private Features in Codespaces					
						
	For any Features hosted in GHCR that are kept private, the `GITHUB_TOKEN` access token in your environment will need to have `package:read` and `contents:read` for the associated repository.					
						
	Many implementing tools use a broadly scoped access token and will work automatically. GitHub Codespaces uses repo-scoped tokens, and therefore you'll need to add the permissions in `devcontainer.json`					
						
	An example `devcontainer.json` can be found below.					
						
	```jsonc					
	{					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"ghcr.io/my-org/private-features/hello:1": {					
	"greeting": "Hello"					
	}					
	},					
	"customizations": {					
	"codespaces": {					
	"repositories": {					
	"my-org/private-features": {					
	"permissions": {					
	"packages": "read",					
	"contents": "read"					
	}					
	}					
	}					
	}					
	}					
	}					
	```					
					26  src/color/README.md	
	@@ -0,0 +1,26 @@					
						
	# My Favorite Color (color)					
						
	A feature to remind you of your favorite color					
						
	## Example Usage					
						
	```json					
	"features": {					
	"ghcr.io/devcontainers/feature-starter/color:1": {					
	"version": "latest"					
	}					
	}					
	```					
						
	## Options					
						
	| Options Id | Description | Type | Default Value |					
	|-----|-----|-----|-----|					
	| favorite | Choose your favorite color. | string | red |					
						
						
						
	---					
						
	_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/feature-starter/blob/main/src/color/devcontainer-feature.json). Add additional notes to a `NOTES.md`._					
					21  src/color/devcontainer-feature.json	
	@@ -0,0 +1,21 @@					
	{					
	"name": "My Favorite Color",					
	"id": "color",					
	"version": "1.0.3",					
	"description": "A feature to remind you of your favorite color",					
	"options": {					
	"favorite": {					
	"type": "string",					
	"enum": [					
	"red",					
	"gold",					
	"green"					
	],					
	"default": "red",					
	"description": "Choose your favorite color."					
	}					
	},					
	"installsAfter": [					
	"ghcr.io/devcontainers/features/common-utils"					
	]					
	}					
					26  src/color/install.sh	
	@@ -0,0 +1,26 @@					
	#!/bin/sh					
	set -e					
						
	echo "Activating feature 'color'"					
	echo "The provided favorite color is: ${FAVORITE}"					
						
						
	# The 'install.sh' entrypoint script is always executed as the root user.					
	#					
	# These following environment variables are passed in by the dev container CLI.					
	# These may be useful in instances where the context of the final					
	# remoteUser or containerUser is useful.					
	# For more details, see https://containers.dev/implementors/features#user-env-var					
	echo "The effective dev container remoteUser is '$_REMOTE_USER'"					
	echo "The effective dev container remoteUser's home directory is '$_REMOTE_USER_HOME'"					
						
	echo "The effective dev container containerUser is '$_CONTAINER_USER'"					
	echo "The effective dev container containerUser's home directory is '$_CONTAINER_USER_HOME'"					
						
	cat > /usr/local/bin/color \					
	<< EOF					
	#!/bin/sh					
	echo "my favorite color is ${FAVORITE}"					
	EOF					
						
	chmod +x /usr/local/bin/color					
					26  src/hello/README.md	
	@@ -0,0 +1,26 @@					
						
	# Hello, World! (hello)					
						
	A hello world feature					
						
	## Example Usage					
						
	```json					
	"features": {					
	"ghcr.io/devcontainers/feature-starter/hello:1": {					
	"version": "latest"					
	}					
	}					
	```					
						
	## Options					
						
	| Options Id | Description | Type | Default Value |					
	|-----|-----|-----|-----|					
	| greeting | Select a pre-made greeting, or enter your own | string | hey |					
						
						
						
	---					
						
	_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/feature-starter/blob/main/src/hello/devcontainer-feature.json). Add additional notes to a `NOTES.md`._					
					22  src/hello/devcontainer-feature.json	
	@@ -0,0 +1,22 @@					
	{					
	"name": "Hello, World!",					
	"id": "hello",					
	"version": "1.0.2",					
	"description": "A hello world feature",					
	"options": {					
	"greeting": {					
	"type": "string",					
	"proposals": [					
	"hey",					
	"hello",					
	"hi",					
	"howdy"					
	],					
	"default": "hey",					
	"description": "Select a pre-made greeting, or enter your own"					
	}					
	},					
	"installsAfter": [					
	"ghcr.io/devcontainers/features/common-utils"					
	]					
	}					
					29  src/hello/install.sh	
	@@ -0,0 +1,29 @@					
	#!/bin/sh					
	set -e					
						
	echo "Activating feature 'hello'"					
						
	GREETING=${GREETING:-undefined}					
	echo "The provided greeting is: $GREETING"					
						
	# The 'install.sh' entrypoint script is always executed as the root user.					
	#					
	# These following environment variables are passed in by the dev container CLI.					
	# These may be useful in instances where the context of the final					
	# remoteUser or containerUser is useful.					
	# For more details, see https://containers.dev/implementors/features#user-env-var					
	echo "The effective dev container remoteUser is '$_REMOTE_USER'"					
	echo "The effective dev container remoteUser's home directory is '$_REMOTE_USER_HOME'"					
						
	echo "The effective dev container containerUser is '$_CONTAINER_USER'"					
	echo "The effective dev container containerUser's home directory is '$_CONTAINER_USER_HOME'"					
						
	cat > /usr/local/bin/hello \					
	<< EOF					
	#!/bin/sh					
	RED='\033[0;91m'					
	NC='\033[0m' # No Color					
	echo "\${RED}${GREETING}, \$(whoami)!\${NC}"					
	EOF					
						
	chmod +x /usr/local/bin/hello					
					33  test/_global/color_and_hello.sh	
	@@ -0,0 +1,33 @@					
	#!/bin/bash					
						
	# The 'test/_global' folder is a special test folder that is not tied to a single feature.					
	#					
	# This test file is executed against a running container constructed					
	# from the value of 'color_and_hello' in the tests/_global/scenarios.json file.					
	#					
	# The value of a scenarios element is any properties available in the 'devcontainer.json'.					
	# Scenarios are useful for testing specific options in a feature, or to test a combination of features.					
	#					
	# This test can be run with the following command (from the root of this repo)					
	# devcontainer features test --global-scenarios-only .					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	source dev-container-features-test-lib					
						
	echo -e "The result of the 'color' command will be:\n"					
	color					
	echo -e "The result of the 'hello' command will be:\n"					
	hello					
	echo -e "\n"					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "check purple is my favorite color" bash -c "color | grep 'my favorite color is purple'"					
	check "check I am greeting with 'Greetings'" bash -c "hello | grep 'Greetings, $(whoami)'"					
						
						
	# Report result					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
					13  test/_global/scenarios.json	
	@@ -0,0 +1,13 @@					
	{					
	"color_and_hello": {					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"color": {					
	"favorite": "purple"					
	},					
	"hello": {					
	"greeting": "Greetings"					
	}					
	}					
	}					
	}					
					17  test/color/gold.sh	
	@@ -0,0 +1,17 @@					
	#!/bin/bash					
						
	# This test file will be executed against one of the scenarios devcontainer.json test that					
	# includes the 'color' feature with "favorite": "gold" option.					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	source dev-container-features-test-lib					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "execute command" bash -c "color | grep 'my favorite color is gold'"					
						
	# Report result					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
					17  test/color/green.sh	
	@@ -0,0 +1,17 @@					
	#!/bin/bash					
						
	# This test file will be executed against one of the scenarios devcontainer.json test that					
	# includes the 'color' feature with "favorite": "green" option.					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	source dev-container-features-test-lib					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "execute command" bash -c "color | grep 'my favorite color is green'"					
						
	# Report result					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
					31  test/color/my_favorite_color_is_green.sh	
	@@ -0,0 +1,31 @@					
	#!/bin/bash					
						
	# This test file will be executed against after building a container with the					
	# 'my_favorite_color_is_green' scenario in 'test/test/color/scenarios.json'.					
	#					
	# For more information, see: https://github.com/devcontainers/cli/blob/main/docs/features/test.md					
	#					
	# This scenario first uses the 'common-utils' Features to add a new user 'octocat'.					
	# It then installs the 'color' Feature with the FAVORITE option set to 'green' (the default FAVORITE value if none provided is 'red').					
	#					
	#					
	# This test (as well as any of the other scenarios in 'scenarios.json') can be run with the following command:					
	#					
	# devcontainer features test \					
	# --features color \					
	# --skip-autogenerated \					
	# /path/to/this/repo					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	# Provides the 'check' and 'reportResults' commands.					
	source dev-container-features-test-lib					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "validate favorite color" color | grep 'my favorite color is green'					
						
	# Report result					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
					33  test/color/scenarios.json	
	@@ -0,0 +1,33 @@					
	{					
	"my_favorite_color_is_green": {					
	"image": "mcr.microsoft.com/devcontainers/base:focal",					
	"features": {					
	"ghcr.io/devcontainers/features/common-utils:1": {					
	"installZsh": false,					
	"installOhMyZsh": false,					
	"upgradePackages": false,					
	"username": "octocat"					
	},					
	"color": {					
	"favorite": "green"					
	}					
	},					
	"remoteUser": "octocat"					
	},					
	"gold": {					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"color": {					
	"favorite": "gold"					
	}					
	}					
	},					
	"green": {					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"color": {					
	"favorite": "green"					
	}					
	}					
	}					
	}					
					11,592  test/color/test.sh	
					Load diff	
					Large diffs are not rendered by default.	
					17  test/hello/hello.sh	
	@@ -0,0 +1,17 @@					
	#!/bin/bash					
						
	# This test file will be executed against one of the scenarios devcontainer.json test that					
	# includes the 'color' feature with "greeting": "hello" option.					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	source dev-container-features-test-lib					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "execute command" bash -c "hello | grep 'hello, $(whoami)!'"					
						
	# Report results					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
					10  test/hello/scenarios.json	
	@@ -0,0 +1,10 @@					
	{					
	"hello": {					
	"image": "mcr.microsoft.com/devcontainers/base:ubuntu",					
	"features": {					
	"hello": {					
	"greeting": "hello"					
	}					
	}					
	}					
	}					
					45  test/hello/test.sh	
	@@ -0,0 +1,45 @@					
	#!/bin/bash					
						
	# This test file will be executed against an auto-generated devcontainer.json that					
	# includes the 'hello' Feature with no options.					
	#					
	# For more information, see: https://github.com/devcontainers/cli/blob/main/docs/features/test.md					
	#					
	# Eg:					
	# {					
	# "image": "<..some-base-image...>",					
	# "features": {					
	# "hello": {}					
	# },					
	# "remoteUser": "root"					
	# }					
	#					
	# Thus, the value of all options will fall back to the default value in					
	# the Feature's 'devcontainer-feature.json'.					
	# For the 'hello' feature, that means the default favorite greeting is 'hey'.					
	#					
	# These scripts are run as 'root' by default. Although that can be changed					
	# with the '--remote-user' flag.					
	#					
	# This test can be run with the following command:					
	#					
	# devcontainer features test \					
	# --features hello \					
	# --remote-user root \					
	# --skip-scenarios \					
	# --base-image mcr.microsoft.com/devcontainers/base:ubuntu \					
	# /path/to/this/repo					
						
	set -e					
						
	# Optional: Import test library bundled with the devcontainer CLI					
	# Provides the 'check' and 'reportResults' commands.					
	source dev-container-features-test-lib					
						
	# Feature-specific tests					
	# The 'check' command comes from the dev-container-features-test-lib.					
	check "execute command" bash -c "hello | grep 'hey, $(whoami)!'"					
						
	# Report results					
	# If any of the checks above exited with a non-zero exit code, the test will fail.					
	reportResults					
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						---
title: 'Creating GitHub Apps'
intro: You can build GitHub Apps for yourself or others to use.
versions:
  fpt: '*'
  ghes: '*'
  ghae: '*'
  ghec: '*'
topics:
  - GitHub Apps
children:
  - /creating-github-apps
  - /authenticating-with-a-github-app
  - /guides
redirect_from:
  - /apps/building-integrations/setting-up-and-registering-github-apps
  - /developers/apps/building-github-apps
---
Skip to main content
Click here to return to Amazon Web Services homepage
Contact Us
Support 
English 
My Account 
Products Solutions Pricing Documentation Learn Partner Network AWS Marketplace Customer Enablement Events Explore More
Amazon Managed Streaming for Apache Kafka Documentation
Run with native Apache Kafka
Amazon Managed Streaming for Apache Kafka (Amazon MSK) supports the deployment of native versions of Apache Kafka so applications and tools built for Apache Kafka work with Amazon MSK.
Streamlined version availability
Amazon MSK typically makes newer versions of Apache Kafka available within days of public availability.
Seamless version upgrades
You can upgrade Apache Kafka versions on Amazon MSK clusters, allowing you to decide when to take advantage of features and bug fixes present in new Apache Kafka versions. Amazon MSK helps with automating the deployment of version upgrades on running clusters to help customers maintain client I/O availability for customers following best practices.
No servers to manage
Fully managed
With a few clicks in the console, you can create a fully managed Apache Kafka cluster that is designed to follow Apache Kafka’s deployment best practices, or you can create your own cluster using your own custom configuration. Once you create your desired configuration, Amazon MSK is designed to provision, configure, and manage the operations of your Apache Kafka cluster and Apache ZooKeeper nodes.
Apache ZooKeeper included
Apache ZooKeeper is required to run Apache Kafka, coordinate cluster tasks, and maintain state for resources interacting with the cluster. Amazon MSK is designed to manage the Apache ZooKeeper nodes for you. Each Amazon MSK cluster is designed to include the appropriate number of Apache ZooKeeper nodes for your Apache Kafka cluster.
Amazon MSK Serverless
MSK Serverless is a cluster type for Amazon MSK that supports running Apache Kafka clusters without having to manage compute and storage capacity. MSK Serverless provisions and scales resources while also managing Apache Kafka partitions..
Availability
Availability
The service is designed so that all clusters are provisioned across multiple availability zones (three availability zones is default), and are supported by systems that seek to detect and respond to issues within cluster infrastructure and Apache Kafka software. If a component fails, Amazon MSK is designed to replace it without downtime to your applications. Amazon MSK assists in the management of the availability of your Apache ZooKeeper nodes so you don’t need to start, stop, or directly access the nodes yourself. Amazon MSK is designed to deploy software patches as needed to help you keep your cluster up-to-date and running smoothly.
Data replication
Amazon MSK is designed to use multi-AZ replication for high-availability.
Security
Private connectivity
Your Apache Kafka clusters are designed to run in an Amazon VPC managed by Amazon MSK. Your clusters are designed to be available to your own Amazon VPCs, subnets, and security groups based on the configuration you specify. The service is designed so that you can control your network configuration and IP addresses from your VPCs that are attached to your Amazon MSK resources through elastic network interfaces (ENIs).

Granular access control
By using IAM Access Control, you no longer need to build and run one-off access management systems to control client authentication and authorization for Apache Kafka and your clusters are secured using least-privileged permissions. You also can use SASL/SCRAM or mutual TLS authentication with Apache Kafka access control lists (ACLs).
Encryption
Amazon MSK is designed to encrypt your data at rest without special configuration or third-party tools. Data can be encrypted at rest using AWS Key Management Service (KMS) Customer Master Key (CMK), or your own CMK. Amazon MSK is also designed to encrypt data in-transit via TLS between brokers and between clients and brokers on your cluster.
Connectivity over the internet
Amazon MSK offers an option to connect to the brokers of Amazon MSK clusters running Apache Kafka 2.6.0 or later versions over the internet. By enabling Public Access, authorized clients external to a private Amazon Virtual Private Cloud (VPC) can stream encrypted data in and out of specific Amazon MSK clusters.
Scalable
Broker scaling
You can scale your Amazon MSK clusters by changing the size or family of your Apache Kafka brokers. Changing the size or family of your brokers is a popular way to scale Amazon MSK clusters because it gives you the flexibility to adjust your MSK cluster’s compute capacity for changes in your workloads. This method can be preferred because it does not require partition reassignment which can impact Apache Kafka availability.
 
Alternatively, you can expand the size of your cluster by up to 100s brokers per cluster using the console or command line interface (CLI).
Cluster scaling (serverless clusters only)
Amazon MSK scales compute and storage resources of your clusters in response to your application’s throughput needs.
Partition management
Amazon MSK integrates with Cruise Control, a popular open source tool for Apache Kafka that manages partition assignment on your behalf.
Storage scaling
You can scale up the amount of storage provisioned per broker to match changes in storage requirements using the AWS management console or AWS CLI or you can create an auto scaling policy to expand your storage to meet your streaming requirements.
Configurable
Amazon MSK is designed to deploy a best practice cluster configuration for Apache Kafka, and gives customers the ability to tune more than 30 different cluster configurations while supporting all dynamic and topic-level configurations.
Visible
CloudWatch metrics by default
You can visualize and monitor important cluster, broker, topic, consumer, and partition-level metrics using Amazon CloudWatch.
Additional Information
For additional information about service controls, security features and functionalities, including, as applicable, information about storing, retrieving, modifying, restricting, and deleting data, please see https://docs.aws.amazon.com/index.html. This additional information does not form part of the Documentation for purposes of the AWS Customer Agreement available at http://aws.amazon.com/agreement, or other agreement between you and AWS governing your use of AWS’s services.

Learn About AWS
What Is AWS?
What Is Cloud Computing?
AWS Diversity, Equity & Inclusion
What Is DevOps?
What Is a Container?
What Is a Data Lake?
AWS Cloud Security
What's New
Blogs
Press Releases
Resources for AWS
Getting Started
Training and Certification
AWS Solutions Library
Architecture Center
Product and Technical FAQs
Analyst Reports
AWS Partners
Developers on AWS
Developer Center
SDKs & Tools
.NET on AWS
Python on AWS
Java on AWS
PHP on AWS
JavaScript on AWS
Help
Contact Us
File a Support Ticket
Knowledge Center
AWS re:Post
AWS Support Overview
Legal
AWS Careers
Amazon is an Equal Opportunity Employer: Minority / Women / Disability / Veteran / Gender Identity / Sexual Orientation / Age.
Language عربي Bahasa Indonesia Deutsch English Español Français Italiano Português Tiếng Việt Türkçe Ρусский ไทย 日本語 한국어 中文 (简体) 中文 (繁體)
Privacy | Site Terms | Cookie Preferences | © 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
